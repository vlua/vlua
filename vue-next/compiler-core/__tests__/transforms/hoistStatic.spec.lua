require("compiler-core/src")
require("compiler-core/src/NodeTypes")
require("compiler-core/src/runtimeHelpers")
require("compiler-core/src/transforms/transformElement")
require("compiler-core/src/transforms/vIf")
require("compiler-core/src/transforms/vFor")
require("compiler-core/src/transforms/vBind")
require("compiler-core/src/transforms/vOn")
require("compiler-core/__tests__/testUtils")
require("compiler-core/src/transforms/transformText")
require("@vue/shared/PatchFlags")
local parse = baseParse

function transformWithHoist(template, options)
  if options == nil then
    options={}
  end
  local ast = parse(template)
  transform(ast, {hoistStatic=true, nodeTransforms={transformIf, transformFor, ..., transformElement, transformText}, directiveTransforms={on=transformOn, bind=transformBind}, ...})
  expect(ast.codegenNode):toMatchObject({type=NodeTypes.VNODE_CALL, isBlock=true})
  return ast
end

describe('compiler: hoistStatic transform', function()
  test('should NOT hoist root node', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(0)
    expect(root.codegenNode):toMatchObject({tag=})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist simple element', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({class='inline'}), children={type=NodeTypes.TEXT, content=}}})
    expect(root.codegenNode):toMatchObject({tag=, props=undefined, children={{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist nested static tree', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=undefined, children={{type=NodeTypes.ELEMENT, tag=}, {type=NodeTypes.ELEMENT, tag=}}}})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist nested static tree with comments', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=undefined, children={{type=NodeTypes.COMMENT, content=}}}})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist siblings with common non-hoistable parent', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=}, {type=NodeTypes.VNODE_CALL, tag=}})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}, {type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should NOT hoist components', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(0)
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should NOT hoist element with dynamic props', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(0)
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({id=}), children=undefined, patchFlag=genFlagText(PatchFlags.PROPS), dynamicProps=}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist element with static key', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(1)
    expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({key='foo'})}})
    expect(root.codegenNode):toMatchObject({tag=, props=undefined, children={{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should NOT hoist element with dynamic key', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(0)
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({key=})}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should NOT hoist element with dynamic ref', function()
    local root = transformWithHoist()
    expect(#root.hoists):toBe(0)
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({ref=}), children=undefined, patchFlag=genFlagText(PatchFlags.NEED_PATCH)}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist static props for elements with directives', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({createObjectMatcher({id='foo'})})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props={type=NodeTypes.SIMPLE_EXPRESSION, content=}, children=undefined, patchFlag=genFlagText(PatchFlags.NEED_PATCH), directives={type=NodeTypes.JS_ARRAY_EXPRESSION}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist static props for elements with dynamic text children', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({createObjectMatcher({id='foo'})})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props={content=}, children={type=NodeTypes.INTERPOLATION}, patchFlag=genFlagText(PatchFlags.TEXT)}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist static props for elements with unhoistable children', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({createObjectMatcher({id='foo'})})
    expect(root.codegenNode.children):toMatchObject({{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props={content=}, children={{type=NodeTypes.ELEMENT, tag=}}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should hoist v-if props/children if static', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({createObjectMatcher({key=, id='foo'}), {type=NodeTypes.VNODE_CALL, tag=}})
    expect(root.children[0+1].children[0+1].codegenNode):toMatchObject({type=NodeTypes.JS_CONDITIONAL_EXPRESSION, consequent={type=NodeTypes.VNODE_CALL, tag=, props={content=}, children={{codegenNode={content=}}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('should hoist v-for children if static', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({createObjectMatcher({id='foo'}), {type=NodeTypes.VNODE_CALL, tag=}})
    local forBlockCodegen = root.children[0+1].children[0+1].codegenNode
    expect(forBlockCodegen):toMatchObject({type=NodeTypes.VNODE_CALL, tag=FRAGMENT, props=undefined, children={type=NodeTypes.JS_CALL_EXPRESSION, callee=RENDER_LIST}, patchFlag=genFlagText(PatchFlags.UNKEYED_FRAGMENT)})
    local innerBlockCodegen = ().children.arguments[1+1]
    expect(innerBlockCodegen.returns):toMatchObject({type=NodeTypes.VNODE_CALL, tag=, props={content=}, children={{codegenNode={content=}}}})
    expect(generate(root).code):toMatchSnapshot()
  end
  )
  test('hoist static text node between elements', function()
    local root = transformWithHoist()
    expect(root.hoists):toMatchObject({{callee=CREATE_TEXT, arguments={{type=NodeTypes.TEXT, content=}}}, {type=NodeTypes.VNODE_CALL, tag=}})
  end
  )
  describe('prefixIdentifiers', function()
    test('hoist nested static tree with static interpolation', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=undefined, children={type=NodeTypes.COMPOUND_EXPRESSION}}})
      expect(root.codegenNode):toMatchObject({tag=, props=undefined, children={{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}}})
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('hoist nested static tree with static prop value', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(root.hoists):toMatchObject({{type=NodeTypes.VNODE_CALL, tag=, props=createObjectMatcher({foo=}), children={type=NodeTypes.INTERPOLATION, content={content=, isStatic=false, isConstant=true}}}})
      expect(root.codegenNode):toMatchObject({tag=, props=undefined, children={{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.SIMPLE_EXPRESSION, content=}}}})
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('hoist class with static object value', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(root.hoists):toMatchObject({{type=NodeTypes.JS_OBJECT_EXPRESSION, properties={{key={content=, isConstant=true, isStatic=true}, value={content=, isConstant=true, isStatic=false}}}}})
      expect(root.codegenNode):toMatchObject({tag=, props=undefined, children={{type=NodeTypes.ELEMENT, codegenNode={type=NodeTypes.VNODE_CALL, tag=, props={type=NodeTypes.SIMPLE_EXPRESSION, content=}, children={type=NodeTypes.INTERPOLATION, content={content=, isConstant=false, isStatic=false}}, patchFlag=}}}})
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('should NOT hoist expressions that refer scope variables', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(#root.hoists):toBe(0)
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('should NOT hoist expressions that refer scope variables (2)', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(#root.hoists):toBe(0)
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('should NOT hoist expressions that refer scope variables (v-slot)', function()
      local root = transformWithHoist({prefixIdentifiers=true})
      expect(#root.hoists):toBe(0)
      expect(generate(root).code):toMatchSnapshot()
    end
    )
    test('should NOT hoist elements with cached handlers', function()
      local root = transformWithHoist({prefixIdentifiers=true, cacheHandlers=true})
      expect(root.cached):toBe(1)
      expect(#root.hoists):toBe(0)
      expect(generate(root, {mode='module', prefixIdentifiers=true}).code):toMatchSnapshot()
    end
    )
  end
  )
end
)
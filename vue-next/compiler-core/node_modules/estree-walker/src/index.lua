
function walk(ast, )
  return visit(ast, nil, enter, leave)
end

local should_skip = false
local replacement = nil
local context = {skip=function()
  should_skip = true
end
, replace=function(node)
  replacement = node
end
}
local childKeys = {}
function replace(parent, prop, index, node)
  if parent then
    if index ~= nil then
      -- [ts2lua]parent下标访问可能不正确
      -- [ts2lua]parent[prop]下标访问可能不正确
      parent[prop][index] = node
    else
      -- [ts2lua]parent下标访问可能不正确
      parent[prop] = node
    end
  end
end

function visit(node, parent, enter, leave, prop, index)
  if node then
    if enter then
      local _should_skip = should_skip
      local _replacement = replacement
      should_skip = false
      replacement = nil
      enter:call(context, node, parent, prop, index)
      if replacement then
        node = replacement
        replace(parent, prop, index, node)
      end
      local skipped = should_skip
      should_skip = _should_skip
      replacement = _replacement
      if skipped then
        return node
      end
    end
    -- [ts2lua]childKeys下标访问可能不正确
    -- [ts2lua]childKeys下标访问可能不正确
    local keys = node.type and childKeys[node.type] or (childKeys[node.type] = Object:keys(node):filter(function(key)
      -- [ts2lua]node下标访问可能不正确
      type(node[key]) == 'object'
    end
    ))
    local i = 0
    repeat
      local key = keys[i+1]
      -- [ts2lua]node下标访问可能不正确
      local value = node[key]
      if Array:isArray(value) then
        local j = 0
        repeat
          (value[j+1] and value[j+1].type) and visit(value[j+1], node, enter, leave, key, j)
          j = j + 1
        until not(j < #value)
      elseif value and value.type then
        visit(value, node, enter, leave, key, nil)
      end
      i = i + 1
    until not(i < #keys)
    if leave then
      local _replacement = replacement
      replacement = nil
      leave:call(context, node, parent, prop, index)
      if replacement then
        node = replacement
        replace(parent, prop, index, node)
      end
      replacement = _replacement
    end
  end
  return node
end

-- Generated by node-lua-distiller(version: 0.2.6)  at Mon Dec 23 2019 00:00:45 GMT+0800 (GMT+08:00)

---------------------------------------


if __DISTILLER == nil then
    __DISTILLER = nil
    __DISTILLER = {
        FACTORIES = { },
        __nativeRequire = require,
        require = function(id)
            assert(type(id) == "string", "require invalid id:" .. tostring(id))
            if package.loaded[id] then
                return package.loaded[id]
            end
            if __DISTILLER.FACTORIES[id] then
                print('require from define ' .. id);
                local func = __DISTILLER.FACTORIES[id]
                package.loaded[id] = func(__DISTILLER.require) or true
                return package.loaded[id]
            end
            return __DISTILLER.__nativeRequire(id)
        end,
        define = function(self, id, factory)
            assert(type(id) == "string", "invalid id:" .. tostring(id))
            assert(type(factory) == "function", "invalid factory:" .. tostring(factory))
            if package.loaded[id] == nil and self.FACTORIES[id] == nil then
                self.FACTORIES[id] = factory
            else
                print("[__DISTILLER::define] module " .. tostring(id) .. " is already defined")
            end
        end,
        exec = function(self, id)
            local func = self.FACTORIES[id]
            assert(func, "missing factory method for id " .. tostring(id))
            return func(__DISTILLER.require)
        end
    }
end
__DISTILLER:define("vlua.util", function(require)
local typeof = type
local getmetatable = getmetatable
local setmetatable = setmetatable
local next = next
local find, format, sub, gsub = string.find, string.format, string.sub, string.gsub
local tonumber = tonumber
local tostring = tostring
local tremove = table.remove
local tinsert = table.insert
local min = math.min

local emptyObject = {}

--- 基于原型创建一个对象
local function createObject(prototype)
    if prototype then
        return setmetatable({}, prototype)
    else
        return {}
    end
end

local PlainObject = {}
local V_GETTER = 1
local V_SETTER = 2

--- 创建平摊的带属性的对象
local function createPlainObjectMetatable()
    local properties = {}

    ---@class ReactiveMetatable
    local mt = {}
    mt.__properties = properties
    mt.__index = function(self, key)
        local property = properties[key]
        if property then
            return property[V_GETTER](self)
        end
    end

    mt.__newindex = function(self, key, value)
        local property = properties[key]
        if property then
            property[V_SETTER](self, value)
        else
            properties[key] = {
                function(self)
                    return value
                end,
                function(self, newValue)
                    value = newValue
                end
            }
        end
    end

    mt.__pairs = function(self)
        local key, valueStore
        return function()
            key, valueStore = next(properties, key)
            return key, valueStore and valueStore[V_GETTER](self)
        end
    end

    mt.__ipairs = function(self)
        local i = 1
        local valueStore
        return function()
            valueStore = properties[i]
            i = i + 1
            return i, valueStore and valueStore[V_GETTER](self)
        end
    end

    mt.__len = function()
        return #properties
    end

    setmetatable(mt, PlainObject)
    return mt
end

--- 创建平摊的带属性的对象
local function createPlainObject()
    local instance = {}
    local mt = createPlainObjectMetatable()
    setmetatable(instance, mt)
    return instance
end


local function isPlainObject(obj)
    return type(obj) == "table" and getmetatable(obj) == nil
end

--[[ eslint-disable no-unused-vars ]]
--[[*
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https:--flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).
 ]]
 local function noop()
 end



--- 创建一个属性
local function defineProperty(target, key, getter, setter)
    local mt = getmetatable(target)
    assert(mt, "not plain object or reactive object")
    local properties = mt.__properties
    assert(mt, "not plain object or reactive object")
    properties[key] = {getter or noop, setter or function()error('no setter for key : '.. key)end}
end

-- These helpers produce better VM code in JS engines due to their
-- explicitness and function inlining.
local function isUndef(v)
    return v == nil
end

local function isDef(v)
    return v ~= nil
end

local function isTrue(v)
    return v == true
end

local function isFalse(v)
    return v == false
end

--[[*
 * Check if value is primitive.
 ]]
local function isPrimitive(value)
    return (typeof(value) == "string" or typeof(value) == "number" or typeof(value) == "boolean")
end

--[[*
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 ]]
local function isObject(obj)
    return typeof(obj) == "table"
end

--[[*
 * Get the raw type string of a value, e.g., [object Object].
 ]]
local tostring = tostring
local getmetatable = getmetatable

local function toRawType(value)
    return tostring(value)
end

--[[*
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 ]]
local function isPlainObject(obj)
    return typeof(obj) == "table" and getmetatable(obj) == nil
end

local function isCallable(fn)
    local t = type(fn)
    return t == "function" or (getmetatable(fn) and type(getmetatable(fn).__call) == "function")
end

local function isPromise(val)
    return false
end

--[[*
 * Convert a value to a string that is actually rendered.
 ]]
local function toString(val)
    return val == nil and "" or
        ((Array.isArray(val) or (isPlainObject(val) and val.toString == tostring)) and JSON.stringify(val, nil, 2) or
            tostring(val))
end

--[[*
 * Convert an input value to a number for persistence.
 * If the conversion fails, return original string.
 ]]
local function toNumber(val)
    return tonumber(val)
end
-- 切割函数(split功能)
---@param szFullString string 待切割数据
---@param szSeparator string 切割判断
---@return string
local function split(szFullString, szSeparator)
    local nFindStartIndex = 1
    local nSplitIndex = 1
    local nSplitArray = {}
    while true do
        local nFindLastIndex = string.find(szFullString, szSeparator, nFindStartIndex)
        if not nFindLastIndex then
            nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, string.len(szFullString))
            break
        end
        nSplitArray[nSplitIndex] = string.sub(szFullString, nFindStartIndex, nFindLastIndex - 1)
        nFindStartIndex = nFindLastIndex + string.len(szSeparator)
        nSplitIndex = nSplitIndex + 1
    end
    return nSplitArray
end

--[[*
 * Make a map and return a function for checking if a key
 * is in that map.
 ]]
local function makeMap(str, expectsLowerCase)
    local map = createObject(nil)
    local list = split(str, ",")
    for i = 1, #list do
        map[list[i]] = true
    end
    return expectsLowerCase and function(val)
            return map[string.lower(val)]
        end or function(val)
            return map[val]
        end
end

--[[*
 * Check if a tag is a built-in tag.
 ]]
local isBuiltInTag = makeMap("slot,component", true)

--[[*
 * Check if an attribute is a reserved attribute.
 ]]
local isReservedAttribute = makeMap("key,ref,slot,slot-scope,is")

--[[*
 * Remove an item from an array.
 ]]
local function remove(arr, item)
    if (arr.length) then
        local index = arr.indexOf(item)
        if (index > -1) then
            return arr.splice(index, 1)
        end
    end
end

--[[*
 * Check whether an object has the property.
 ]]
local function hasOwn(obj, key)
    return obj[key] ~= nil
end

--[[*
 * Create a cached version of a pure function.
 ]]
local function cached(fn)
    local cache = createObject(nil)
    return function(str)
        local hit = cache[str]
        if not hit then
            hit = fn(str)
            cache[str] = hit
        end
        return hit
    end
end

--[[*
 * Camelize a hyphen-delimited string.
 ]]
local camelizeRE = "-(\\w)"
local camelize =
    cached(
    function(str)
        return string.gsub(
            str,
            camelizeRE,
            function(_, c)
                return c and string.upper(c) or ""
            end
        )
    end
)

--[[*
 * Capitalize a string.
 ]]
local capitalize =
    cached(
    ---@param str string
    function(str)
        return string.upper(str[1]) .. string.sub(str, 2)
    end
)

--[[*
 * Hyphenate a camelCase string.
 ]]
local hyphenateRE = "\\B([A-Z])"
local hyphenate =
    cached(
    function(str)
        return string.lower(string.gsub(str, hyphenateRE, "-$1"))
    end
)

--[[*
 * Convert an Array-like object to a real Array.
 ]]
local function toArray(list, start)
    start = (start or 1) - 1
    local i = #list - start
    local ret = {}
    for j = 1, i do
        ret[j] = list[j + start]
    end
    return ret
end

--[[*
 * Mix properties into target object.
 ]]
local function extend(to, _from)
    for key, value in pairs(_from) do
        to[key] = value
    end
    return to
end

--[[*
 * Merge an Array of Objects into a single Object.
 ]]
local function toObject(arr)
    local res = {}
    for i = 1, #arr do
        if (arr[i]) then
            extend(res, arr[i])
        end
    end
    return res
end


--[[*
 * Always return false.
 ]]
local no = function(a, b, c)
    return false
end

--[[ eslint-enable no-unused-vars ]]
--[[*
 * Return the same value.
 ]]
local identity = function(_)
    return _
end

--[[*
 * Generate a string containing static keys from compiler modules.
 ]]
local function genStaticKeys(modules)
    return modules.reduce(
        function(keys, m)
            return keys.concat(m.staticKeys or {})
        end,
        {}
    ).join(",")
end

--[[*
 * Ensure a function is called only once.
 ]]
local function once(fn)
    local called = false
    return function(...)
        if (not called) then
            called = true
            return fn(...)
        end
    end
end

local function isArray(obj)
    return typeof(obj) == "table"
end

local function concat(...)
    local args = {...}
    local result = {}
    for i = 1, #args do
        local t = args[i]
        for j = 1, #t do
            tinsert(result, t[i])
        end
    end
    return result
end
local function indexOf(t, v)
    for i = 1, #t do
        if t[i] == v then
            return i
        end
    end
    return 0
end

local warn = print
local hasSymbol = false
local function isServerRendering()
    return false
end

---@param handler Function
---@param args null | any[]
---@param vm any
---@param info string
local function invokeWithErrorHandling(handler, vm, info, ...)
    local res
    --   try {
    res = handler(...)
    -- if (res && !res._isVue && isPromise(res) && !res._handled) {
    --   res.catch(e => handleError(e, vm, info + ` (Promise/async)`))
    --   -- issue #9511
    --   -- avoid catch triggering multiple times when nested calls
    --   res._handled = true
    -- }
    --   } catch (e) {
    --     handleError(e, vm, info)
    --   }
    return res
end

--[[]
 * unicode letters used for parsing html tags, component names and property paths.
 * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname
 * skipping \u10000-\uEFFFF due to it freezing up PhantomJS
]]
--export const unicodeRegExp = /a-zA-Z\u00B7\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u037D\u037F-\u1FFF\u200C-\u200D\u203F-\u2040\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD/

-- Check if a string starts with $ or _
---@param str string
---@return boolean
local function isReserved(str)
    local c = string.byte(str, 1)
    return c == 0x24 or c == 0x5F
end

local function parse_path(path)
    if not path or path == "" then
        error("invalid path:" .. tostring(path))
    end
    --print('start to parse ' .. path)
    local result = {}
    local i, n = 1, #path
    while i <= n do
        local s, e, split1, key, split2 = find(path, "([%.%[])([^%.^%[^%]]+)(%]?)", i)
        if not s or s > i then
            --print('"'.. sub(path, i, s and s - 1).. '"')
            tinsert(result, sub(path, i, s and s - 1))
        end
        if not s then
            break
        end
        if split1 == "[" then
            if split2 ~= "]" then
                error("invalid path:" .. path)
            end
            key = tonumber(key)
            if not key then
                error("invalid path:" .. path)
            end
            --print(key)
            tinsert(result, key)
        else
            --print('"'.. key .. '"')
            tinsert(result, key)
        end
        i = e + 1
    end
    --print('finish parse ' .. path)
    return result
end

---@param path string
local function parsePath(path)
    local segments = parse_path(path)
    return function(obj)
        for i = 1, #segments do
            if (not obj) then
                return
            end
            obj = obj[segments[i]]
        end
        return obj
    end
end

local function removeArrayItem(t, item)
    for i, v in ipairs(t) do
        if v == item then
            tremove(t, i)
            break
        end
    end
end
local function slice(array)
    local newArray = {}
    for i = 1, #array do
        newArray[i] = array[i]
    end
    return newArray
end

---@param name string
local function class(name, super)
    local cls = {}
    cls.__name = name
    cls.__index = cls
    cls.new = function(...)
        local instance = {}
        setmetatable(instance, cls)
        if cls.ctor then
            cls.ctor(instance, ...)
        end
        return instance
    end
    if super then
        setmetatable(cls, super)
    end
    return cls, super
end

-- http://phi.lho.free.fr/programming/TestLuaArray.lua.html
-- TODO move this to helpers
-- Emulate the splice function of JS (or array_splice of PHP)
-- I keep the imperfect parameter names from the Mozilla doc.
-- http://developer.mozilla.org/en/docs/Core_JavaScript_1.5_Reference:Global_Objects:Array:splice
-- I use 1-based indices, of course.
local function splice(t, index, howMany, ...)
    local removed = {}
    local tableSize = #t -- Table size
    -- Lua 5.0 handling of vararg...
    local args = {...}
    local argNb = #args -- Number of elements to insert
    -- Check parameter validity
    if index < 1 then
        index = 1
    end
    if howMany < 0 then
        howMany = 0
    end
    if index > tableSize then
        index = tableSize + 1 -- At end
        howMany = 0 -- Nothing to delete
    end
    if index + howMany - 1 > tableSize then
        howMany = tableSize - index + 1 -- Adjust to number of elements at index
    end

    local argIdx = 1 -- Index in arg
    -- Replace min(howMany, argNb) entries
    for pos = index, index + min(howMany, argNb) - 1 do
        -- Copy removed entry
        tinsert(removed, t[pos])
        -- Overwrite entry
        t[pos] = args[argIdx]
        argIdx = argIdx + 1
    end
    argIdx = argIdx - 1
    -- If howMany > argNb, remove extra entries
    for i = 1, howMany - argNb do
        tinsert(removed, tremove(t, index + argIdx))
    end
    -- If howMany < argNb, insert remaining new entries
    for i = argNb - howMany, 1, -1 do
        tinsert(t, index + howMany, args[argIdx + i])
    end
    return removed
end

local function instanceof(obj, cls)
    local mt = obj
    while(mt) do
        if mt == cls then
            return true
        end
        mt = getmetatable(mt)
    end
    return false
end

return {
    emptyObject = emptyObject,
    isUndef = isUndef,
    isDef = isDef,
    isTrue = isTrue,
    isFalse = isFalse,
    isPrimitive = isPrimitive,
    isObject = isObject,
    toRawType = toRawType,
    isPlainObject = isPlainObject,
    isCallable = isCallable,
    isPromise = isPromise,
    toString = toString,
    toNumber = toNumber,
    makeMap = makeMap,
    isBuiltInTag = isBuiltInTag,
    isReservedAttribute = isReservedAttribute,
    remove = remove,
    hasOwn = hasOwn,
    cached = cached,
    camelize = camelize,
    capitalize = capitalize,
    hyphenate = hyphenate,
    toArray = toArray,
    extend = extend,
    toObject = toObject,
    noop = noop,
    no = no,
    identity = identity,
    genStaticKeys = genStaticKeys,
    once = once,
    isArray = isArray,
    createObject = createObject,
    defineProperty = defineProperty,
    warn = warn,
    hasSymbol = hasSymbol,
    indexOf = indexOf,
    concat = concat,
    isServerRendering = isServerRendering,
    createPlainObject = createPlainObject,
    createPlainObjectMetatable = createPlainObjectMetatable,
    PlainObject = PlainObject,
    invokeWithErrorHandling = invokeWithErrorHandling,
    parsePath = parsePath,
    removeArrayItem = removeArrayItem,
    class = class,
    slice = slice,
    splice = splice,
    isReserved = isReserved,
    instanceof = instanceof
}

end)



---------------------------------------


__DISTILLER:define("vlua.config", function(require)
return {
    async = false,
    env = 'dev',
    performance = false,
    weex = false,
    optionMergeStrategies = {},
}
end)



---------------------------------------


__DISTILLER:define("vlua.dep", function(require)
local config = require("vlua.config")
local Util = require("vlua.util")
local tinsert = table.insert
local tremove = table.remove
local tsort = table.sort
local tpop = tremove
local removeArrayItem = Util.removeArrayItem
local slice = Util.slice
local class = Util.class

local uid = 0

--[[
 * A dep is an observable that can have multiple
 * directives subscribing to it.
--]]
---@class Dep
---@field target Watcher
---@field id number
---@field subs Watcher[]
local Dep = class("Dep")
function Dep:ctor()
    uid = uid + 1
    self.id = uid
    self.subs = {}
end

---@param sub Watcher
function Dep:addSub(sub)
    tinsert(self.subs, sub)
end

---@param sub Watcher
function Dep:removeSub(sub)
    removeArrayItem(self.subs, sub)
end

function Dep:depend()
    if Dep.target then
        Dep.target:addDep(self)
    end
end

local sortSub = function(a, b)
    return a.id < b.id
end
function Dep:notify()
    if #self.subs == 0 then
        return
    end
    -- stabilize the subscriber list first
    local subs = slice(self.subs)
    if (config.env ~= "production" and not config.async) then
        -- subs aren't sorted in scheduler if not running async
        -- we need to sort them now to make sure they fire in correct
        -- order
        tsort(subs, sortSub)
    end
    for i = 1, #subs do
        subs[i]:update()
    end
end

-- The current target watcher being evaluated.
-- This is globally unique because only one watcher
-- can be evaluated at a time.
Dep.target = nil
local targetStack = {}

---@param target Watcher
Dep.pushTarget = function(target)
    tinsert(targetStack, target)
    Dep.target = target
end

Dep.popTarget = function()
    tpop(targetStack)
    Dep.target = targetStack[#targetStack]
end

return Dep

end)



---------------------------------------


__DISTILLER:define("vlua.apiComputed", function(require)
local Util = require("vlua.util")
local Dep = require("vlua.dep")
local warn = Util.warn
local setmetatable = setmetatable
local type = type

---@class Computed
---@field value any
---@field get fun():any
---@param set fun(newValue:any):nil

---@param getter fun(self:any):any
---@param setter fun(self:any, newValue:any):nil
---@return Computed
local function computed(getter, setter)
    local dep = Dep.new()

    if not getter then
        getter = function(self)
            warn("set only computed value")
        end
    end
    if not setter then
        setter = function(self, newValue)
            warn("readonly computed value")
        end
    end

    local function computedGetter(self)
        local value = getter(self)
        if (Dep.target) then
            dep:depend()
        end
        return value
    end

    local function computedSetter(self, newValue)
        setter(self, newValue)
        dep:notify()
    end

    local RefMetatable = {
        __index = function(self, key)
            assert(key == "value", 'only access Computed getter with "value" key')
            return computedGetter(self)
        end,
        __newindex = function(self, key, newValue)
            assert(key == "value", 'only access Computed setter with "value" key')
            computedSetter(self, newValue)
        end
    }
    local obj = {
        get = function()
            return computedGetter(nil)
        end,
        set = function(newValue)
            computedSetter(nil, newValue)
        end,
        getter = computedGetter,
        setter = computedSetter,
        __iscomputed = true
    }
    setmetatable(obj, RefMetatable)
    return obj
end

local function isComputed(val)
    return type(val) == "table" and val.__iscomputed == true
end

return {
    computed = computed,
    isComputed = isComputed
}

end)



---------------------------------------


__DISTILLER:define("vlua.observer", function(require)
local config = require("vlua.config")
local Dep = require("vlua.dep")
local Util = require("vlua.util")
local Computed = require("vlua.apiComputed")
local isComputed = Computed.isComputed
local pairs = pairs
local ipairs = ipairs
local next = next
local type = type
local warn = print
local rawset = rawset
local getmetatable = getmetatable
local setmetatable = setmetatable
local class = Util.class
local createPlainObjectMetatable, PlainObject = Util.createPlainObjectMetatable, Util.PlainObject
local instanceof = Util.instanceof
local isObject = function(v)
    return type(v) == "table"
end

local V_GETTER = 1
local V_SETTER = 2

--[[
 * In some cases we may want to disable observation inside a component's
 * update computation.
]]
local _shouldObserve = true

---@param value boolean
local function toggleObserving(value)
    _shouldObserve = value
end

local function shouldObserve()
    return _shouldObserve
end

local function isReactivableObject(obj)
    return type(obj) == "table" and (getmetatable(obj) == nil)
end

--[[
 * Observer class that is attached to each observed
 * object. Once attached, the observer converts the target
 * object's property keys into getter/setters that
 * collect dependencies and dispatch updates.
]]
---@class Observer
---@field value ReactiveObject
---@field dep Dep
---@field vmCount integer @number of vms that have self object as root $data
local Observer = class("Observer")

--[[
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
]]
---@param asRootData boolean
---@return Observer | void
---@alias ReactiveObject table
local function observe(value, asRootData)
    if (type(value) ~= "table") then
        return
    end

    ---@type Observer
    local ob
    ---@type ReactiveMetatable
    local mt = getmetatable(value)
    if mt then
        ob = mt.__ob__
    end
    if (ob == nil and _shouldObserve and isReactivableObject(value)) and not value._isVue then
        ob = Observer.new(value)
    end
    if (asRootData and ob) then
        ob.vmCount = ob.vmCount + 1
    end
    return ob
end

--- Define a reactive property on an Object.
---@param obj ReactiveObject
---@param key string
---@param val any
---@param customSetter fun():any
---@param shallow boolean
---@param mt ReactiveMetatable
local function defineReactive(obj, key, val, customSetter, shallow, mt)
    local dep = Dep.new()
    mt = mt or getmetatable(obj)

    if val == nil then
        val = obj[key]
        rawset(obj, key, nil)
    end

    -- support function to computed
    if type(val) == "function" then
        val = Computed.computed(val)
    end

    -- support computed
    if isComputed(val) then
        mt.__properties[key] = {
            val.getter,
            val.setter
        }
        return
    end

    local childOb = not shallow and observe(val)

    local property = {}
    mt.__properties[key] = property

    property[V_GETTER] = function(self)
        if (Dep.target) then
            dep:depend()
            if (childOb) then
                childOb.dep:depend()
            end
        end
        return val
    end

    local ownerOb = mt.__ob__

    property[V_SETTER] = function(self, newVal)
        if (newVal == val) then
            return
        end

        if (config.env ~= "production" and customSetter) then
            customSetter()
        end
        childOb = not shallow and observe(newVal)
        val = newVal
        dep:notify()
        --- delete notify
        if newVal == nil then
            ownerOb.dep:notify()
        end
    end
end

--[[
* Walk through all properties and convert them into
* getter/setters. This method should only be called when
* value type is Object.
]]
---@param obj table
local function walk(obj, mt)
    for k, v in pairs(obj) do
        defineReactive(obj, k, nil, nil, nil, mt)
    end
end

---@param value ReactiveObject
function Observer:ctor(value)
    self.value = value
    local dep = Dep.new()
    self.dep = dep
    self.vmCount = 0

    local mt = createPlainObjectMetatable()
    mt.__ob__ = self
    -- if (Array.isArray(value)) {
    --   if (hasProto) {
    --     protoAugment(value, arrayMethods)
    --   } else {
    --     copyAugment(value, arrayMethods, arrayKeys)
    --   }
    --   self.observeArray(value)
    -- } else {
    walk(value, mt)
    -- }

    local properties = mt.__properties

    mt.__index = function(self, key)
        local property = properties[key]
        if property then
            return property[V_GETTER](self)
        end
    end
    mt.__newindex = function(self, key, newValue)
        local property = properties[key]
        if property then
            property[V_SETTER](self, newValue)
        else
            defineReactive(value, key, newValue, nil, nil, mt)
            --- add notify
            dep:notify()
        end
    end
    setmetatable(value, mt)
end ---@param target ReactiveObject
--

--[[
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
]]
---@param target ReactiveObject
local function set(target, key, val)
    ---@type ReactiveMetatable
    local mt = getmetatable(target)
    if config.env ~= "production" and (not mt or not mt.__ob__) then
        warn("Cannot set reactive property on undefined, null, or primitive value: ${(target: any)}")
    end

    -- 如果已经有这个值
    if mt.__properties[key] then
        target[key] = val
        return val
    end
    local ob = mt.__ob__
    if (target._isVue or (ob and ob.vmCount ~= 0)) then
        if config.env ~= "production" then
            warn(
                "Avoid adding reactive properties to a Vue instance or its root $data " ..
                    "at runtime - declare it upfront in the data option."
            )
            return val
        end
    end
    if (not ob) then
        target[key] = val
        return val
    end

    defineReactive(ob.value, key, val, nil, nil, mt)
    ob.dep:notify()
    return val
end
--- Delete a property and trigger change if necessary.
---@param target ReactiveObjectlocal
local function del(target, key)
    ---@type ReactiveMetatable
    if config.env ~= "production" and not isObject(target) then
        warn("Cannot delete reactive property on undefined, null, or primitive value: ${(target: any)}")
    end

    local ob
    local mt = getmetatable(target)
    if mt then
        ob = mt.__ob__
    end

    if (target._isVue or (ob and ob.vmCount ~= 0)) then
        if config.env ~= "production" then
            warn("Avoid deleting properties on a Vue instance or its root $data " .. "- just set it to null.")
            return
        end
    end
    if (target[key] == nil) then
        return
    end
    target[key] = nil
    if ob then
        ob.dep:notify()
    end
end

Observer.toggleObserving = toggleObserving
Observer.set = set
Observer.del = del
Observer.defineReactive = defineReactive
Observer.observe = observe

Observer.reactive = function(value)
    observe(value)
    return value
end

Observer.shouldObserve = shouldObserve

return Observer

end)



---------------------------------------


__DISTILLER:define("vlua.traverse", function(require)
local seenObjects = {}

local function _traverse(val, seen)
    if type(val) ~= "table" then
        return
    end
    ---@type ReactiveMetatable
    local mt = getmetatable(val)
    if (mt and mt.__ob__) then
        local depId = mt.__ob__.dep.id
        if (seen[depId]) then
            return
        end
        seen[depId] = val
    end
    for i, v in pairs(val) do
        _traverse(i, seen)
        _traverse(v, seen)
    end
end

--[[
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
--]]
local function traverse(val)
    _traverse(val, seenObjects)
    seenObjects = {}
end

return {
    traverse = traverse
}

end)



---------------------------------------


__DISTILLER:define("vlua.nextTick", function(require)
local tinsert = table.insert
local isUsingMicroTask = false

local callbacks = {}
local pending = false

local function flushCallbacks()
    pending = false
    local copies = callbacks
    callbacks = {}
    for i = 1, #copies do
        copies[i]()
    end
end

---@param cb Function
---@param ctx Object
local function nextTick(cb, ctx)
    tinsert(
        callbacks,
        function()
            if (cb) then
                --   try {
                cb(ctx)
            --   } catch (e) {
            --     handleError(e, ctx, 'nextTick')
            --   }
            end
        end
    )
end

return {
    flushCallbacks = flushCallbacks,
    nextTick = nextTick
}

end)



---------------------------------------


__DISTILLER:define("vlua.scheduler", function(require)
local config = require("vlua.config")
local Util = require("vlua.util")
local NextTick = require("vlua.nextTick")
local nextTick, devtools = NextTick.nextTick, Util.devtools
local splice = Util.splice
local tsort = table.sort
local tinsert = table.insert
local warn = print

local MAX_UPDATE_COUNT = 100

---@type Watcher[]
local queue = {}
---@type table<number, boolean>
local has = {}
---@type table<number, number>
local circular = {}
local waiting = false
local flushing = false
local index = 0--[[
 * Reset the scheduler's state.
 --]]
local function resetSchedulerState()
    index = 1
    queue = {}
    has = {}
    if (config.env ~= "production") then
        circular = {}
    end
    waiting = false
    flushing = false
end

local function compareQueue(a, b)
    return a.id < b.id
end
--[[
 * Flush both queues and run the watchers.
 --]]
local function flushSchedulerQueue()
    flushing = true
    ---@type Watcher
    local watcher
    ---@type integer
    local id

    -- Sort queue before flush.
    -- This ensures that:
    -- 1. Components are updated from parent to child. (because parent is always
    --    created before the child)
    -- 2. A component's user watchers are run before its render watcher (because
    --    user watchers are created before the render watcher)
    -- 3. If a component is destroyed during a parent component's watcher run,
    --    its watchers can be skipped.
    tsort(queue, compareQueue)

    -- do not cache length because more watchers might be pushed
    -- as we run existing watchers
    for index = 1, #queue do
        watcher = queue[index]
        if (watcher.before) then
            watcher:before()
        end
        id = watcher.id
        has[id] = nil
        watcher:run()
        -- in dev build, check and stop circular updates.
        if (config.env ~= "production" and has[id] ~= nil) then
            circular[id] = (circular[id] or 0) + 1
            if (circular[id] > MAX_UPDATE_COUNT) then
                warn(
                    "You may have an infinite update loop " +
                        (watcher.user and 'in watcher with expression "${watcher.expression}"' or
                            "in a component render function."),
                    watcher.vm
                )
                break
            end
        end
    end

    resetSchedulerState()

    -- devtool hook
    --[[ istanbul ignore if --]]
    if (devtools and config.devtools) then
        devtools.emit("flush")
    end
end

--[[
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 --]]
---@param watcher Watcher
local function queueWatcher(watcher)
    local id = watcher.id
    if (has[id] == nil) then
        has[id] = true
        if (not flushing) then
            tinsert(queue, watcher)
        else
            -- if already flushing, splice the watcher based on its id
            -- if already past its id, it will be run next immediately.
            local i = queue.length - 1
            while (i > index and queue[i].id > watcher.id) do
                i = i - 1
            end
            splice(queue, i + 1, 0, watcher)
        end
        -- queue the flush
        if (not waiting) then
            waiting = true

            if (config.env ~= "production" and not config.async) then
                flushSchedulerQueue()
                return
            end
            nextTick(flushSchedulerQueue)
        end
    end
end

return {
    queueWatcher = queueWatcher
}

end)



---------------------------------------


__DISTILLER:define("vlua.watcher", function(require)
local config = require("vlua.config")
local Util = require("vlua.util")
local Dep = require("vlua.dep")
local Traverse = require("vlua.traverse")
local Scheduler = require("vlua.scheduler")
local tinsert = table.insert
local tremove = table.remove
local tsort = table.sort
local warn = print
local type = type
local getmetatable = getmetatable
local setmetatable = setmetatable
local parsePath = Util.parsePath
local removeArrayItem = Util.removeArrayItem
local pushTarget = Dep.pushTarget
local popTarget = Dep.popTarget
local traverse = Traverse.traverse
local class = Util.class
local queueWatcher = Scheduler.queueWatcher

local uid = 0

---@class WatcherOptions
---@field deep boolean
---@field user boolean
---@field lazy boolean
---@field sync boolean
---@field before Function
---@field onStop Function

---@alias SimpleSet table
---@alias Function fun():nil
--[[
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
--]]
---@class Watcher
---@field source any
---@field expression string
---@field cb Function
---@field id number
---@field deep boolean
---@field user boolean
---@field lazy boolean
---@field sync boolean
---@field dirty boolean
---@field active boolean
---@field deps Dep[]
---@field newDeps Dep[]
---@field depIds SimpleSet
---@field newDepIds SimpleSet
---@field before Function
---@field getter Function
---@field value any
local Watcher = class("Watcher")

local function _()
    Watcher.new = Watcher.ctor
end
---@param source any
---@param expOrFn string | Function
---@param cb Function
---@param options WatcherOptions
---@return Watcher
function Watcher:ctor(source, expOrFn, cb, options)
    self.source = source
    -- options
    if (options) then
        self.deep = options.deep
        self.user = options.user
        self.lazy = options.lazy
        self.sync = options.sync
        self.before = options.before
        self.onStop = options.onStop
    else
        self.deep = false
        self.user = false
        self.lazy = false
        self.sync = false
    end
    self.cb = cb
    uid = uid + 1
    if uid == 17 or uid == 19 then
        print('')
    end
    self.id = uid -- uid for batching
    self.active = true
    self.dirty = self.lazy -- for lazy watchers
    self.deps = {}
    self.newDeps = {}
    self.depIds = {}
    self.newDepIds = {}
    self.expression = config.env ~= "production" and expOrFn or ""
    -- parse expression for getter
    if (type(expOrFn) == "function") then
        self.getter = expOrFn
    else
        self.getter = parsePath(expOrFn)
        if (not self.getter) then
            self.getter = function()
            end
            if config.env ~= "production" then
                warn(
                    'Failed watching path: "${expOrFn}" ' + "Watcher only accepts simple dot-delimited paths. " +
                        "For full control, use a function instead.",
                    vm
                )
            end
        end
    end
    if not self.lazy then
        self.value = self:get()
    end
end

-- Evaluate the getter, and re-collect dependencies.
function Watcher:get()
    pushTarget(self)
    local value
    -- try {
    value = self.getter(self.source)
    -- } catch (e) {
    --   if (self.user) {
    --     handleError(e, vm, 'getter for watcher "${self.expression}"')
    --   else
    --     throw e
    --   }
    -- } finally {
    -- "touch" every property so they are all tracked as
    -- dependencies for deep watching
    if (self.deep) then
        traverse(value)
    end
    popTarget()
    self:cleanupDeps()
    -- }
    return value
end

-- Add a dependency to self directive.
---@param dep Dep
function Watcher:addDep(dep)
    local id = dep.id
    if (not self.newDepIds[id]) then
        self.newDepIds[id] = true
        tinsert(self.newDeps, dep)
        if (not self.depIds[id]) then
            dep:addSub(self)
        end
    end
end

--[[
* Clean up for dependency collection.
--]]
function Watcher:cleanupDeps()
    for i = #self.deps, 1, -1 do
        local dep = self.deps[i]
        if (not self.newDepIds[dep.id]) then
            dep:removeSub(self)
        end
    end
    local tmp = self.depIds
    self.depIds = self.newDepIds
    self.newDepIds = tmp
    self.newDepIds = {}
    tmp = self.deps
    self.deps = self.newDeps
    self.newDeps = tmp
    self.newDeps = {}
end

--[[
* Subscriber interface.
* Will be called when a dependency changes.
--]]
function Watcher:update()
    if (self.lazy) then
        self.dirty = true
    elseif (self.sync) then
        self:run()
    else
        queueWatcher(self)
    end
end

--[[
* Scheduler job interface.
* Will be called by the scheduler.
--]]
function Watcher:run()
    if (self.active) then
        local value = self:get()
        if (value ~= self.value or -- Deep watchers and watchers on Object/Arrays should fire even
                -- when the value is the same, because the value may
                -- have mutated.
                type(value) == "table" or self.deep) then
            -- set new value
            local oldValue = self.value
            self.value = value
            if (self.user) then
                --   } catch (e) {
                --     handleError(e, self.vm, 'callback for watcher "${self.expression}"')
                --   }
                --   try {
                self.cb(self.source, value, oldValue)
            else
                self.cb(self.source, value, oldValue)
            end
        end
    end
end

--[[
* Evaluate the value of the watcher.
* This only gets called for lazy watchers.
--]]
function Watcher:evaluate()
    self.value = self:get()
    self.dirty = false
end

--- Depend on all deps collected by self watcher.
function Watcher:depend()
    for i = #self.deps, 1, -1 do
        self.deps[i]:depend()
    end
end

--- Remove self from all dependencies' subscriber list.
function Watcher:teardown()
    if (self.active) then
        if self.onStop then
            self.onStop(self.source)
        end
        for i = #self.deps, 1, -1 do
            self.deps[i]:removeSub(self)
        end
        self.active = false
    end
end

return Watcher

end)



---------------------------------------


__DISTILLER:define("vlua.binder", function(require)
local Util = require("vlua.util")
local Watcher = require('vlua.watcher')
local pairs = pairs
local warn = Util.warn
local xpcall = xpcall
local tinsert, tpop = table.insert, table.remove

---@class Binder
---@field children Binder[]
---@field events table<string, fun():nil>
local Binder = Util.class("Binder")

function Binder:ctor(source, parent)
    self.source = source
    self.parent = parent
end

local HookIds = {
    mounted = 1,
    unmount = 2,
    destroy = 3,
    errorCaptured = 4,
}
Binder.HookIds = HookIds

-- The current target watcher being evaluated.
-- This is globally unique because only one watcher
-- can be evaluated at a time.
---@type Binder
local target = nil
local targetStack = {}

---@param context Binder
local function pushContext(context)
    tinsert(targetStack, context)
    target = context
end

local function popContext()
    tpop(targetStack)
    target = targetStack[#targetStack]
end

function Binder:emit(event, ...)
    local events = self[event]
    if not events then
        return
    end
    for _, cb in pairs(events) do
        cb(...)
    end
end

function Binder:on(event, cb)
    local events = self[event]
    if not events then
        events = {}
        self[event] = events
    end
    events[cb] = cb
end

function Binder:off(event, cb)
    local events = self[event]
    if events then
        events[cb] = nil
    end
end

function Binder:once(event, cb)
    local function callback(...)
        self:off(event, callback)
        cb(...)
    end
    self:on(event, callback)
end

--- unwatch all watcher and teardown
function Binder:teardown()
    self:emit(HookIds.unmount)
    self:emit(HookIds.destroy)
end


function Binder:createChild(source)
    local child = Binder.new(source, self)
    self:onUnmount(function()
        child:teardown()
    end)
    return child
end

--- create a reactive function
---@param fn fun():nil
function Binder:newFunction(fn)
    -- a content hold my watches and all children
    ---@type Binder
    local binder = self and self:createChild() or Binder.new()

    local reactiveFn = function()
        binder:emit(HookIds.unmount)
        pushContext(binder)
        local value =
            xpcall(
            fn,
            function(msg)
                warn("error when new:" .. msg .. " stack :" .. debug.traceback())
                binder:emit(HookIds.errorCaptured, msg)
            end,
            binder
        )
        popContext(binder)
        binder:emit(HookIds.mounted, value)
    end
    -- watch and run one time
    local watcher = Watcher.new(nil, reactiveFn)
    -- only teardown when destory, but not unmount
    binder:once(
        HookIds.destroy,
        function()
            watcher:teardown()
        end
    )
    return binder
end

--- create a reactive function
---@param fn fun():nil
function Binder.apiNew(fn)
    return Binder.newFunction(target, fn)
end

function Binder:onMounted(cb)
    self:on(HookIds.mounted, cb)
end

function Binder:onUnmount(cb)
    self:on(HookIds.unmount, cb)
end

function Binder:onDestroy(cb)
    self:on(HookIds.destroy, cb)
end

function Binder:onErrorCaptured(cb)
    self:on(HookIds.errorCaptured, cb)
end

--- call cb when expr changed
---@param expOrFn string | Function
---@param cb Function
---@param immediacy boolean @call cb when start
function Binder:watch(expOrFn, cb, immediacy)
    -- watch and run one time
    local watcher = Watcher.new(self.source, expOrFn, cb)
    self:onUnmount(function()
        watcher:teardown()
    end)
    if immediacy then
        cb(self.source, watcher.value, watcher.value)
    end
end
return Binder
end)



---------------------------------------


__DISTILLER:define("vlua.apiRef", function(require)
local Util = require("vlua.util")
local Dep = require("vlua.dep")
local warn = Util.warn
local setmetatable = setmetatable
local type = type

---@class Ref
---@field value any
---@field get fun():any
---@param set fun(newValue:any):nil

---@param getter fun(self:any):any
---@param setter fun(self:any, newValue:any):nil
---@return Ref
local function ref(value, isReadonly)
    local dep = Dep.new()

    local function get(self)
        if (Dep.target) then
            dep:depend()
        end
        return value
    end

    local selfSet, set
    if isReadonly then
        set = function()
            warn("readonly ref value")
        end
        selfSet = set
    else
        selfSet = function(self, newValue)
            value = newValue
            dep:notify()
        end
        set = function(newValue)
            value = newValue
            dep:notify()
        end
    end

    local RefMetatable = {
        __index = function(self, key)
            assert(key == "value", 'only access Ref getter with "value" key')
            return get()
        end,
        __newindex = function(self, key, newValue)
            assert(key == "value", 'only access Ref setter with "value" key')
            set(newValue)
        end
    }
    local obj = {
        get = get,
        set = set,
        getter = get,
        setter = selfSet,
        __isref = true
    }
    setmetatable(obj, RefMetatable)
    return obj
end

local function isRef(val)
    return type(val) == "table" and val.__isref == true
end

return {
    ref = ref,
    isRef = isRef
}

end)



---------------------------------------


__DISTILLER:define("vlua.vlua", function(require)
local Computed = require("vlua.apiComputed")
local Observer = require("vlua.observer")
local Binder = require("vlua.binder")
local Ref = require("vlua.apiRef")
local observe = Observer.observe


local function reactive(value)
    observe(value)
    return value
end

local plugins = {}
local function use(plugin)
    assert(plugins[plugin] == nil , "dup plugin")
    plugin.install()
end

local function createBinder(source, parent)
    return Binder.new(source, parent)
end

---@class vlua
local vlua = {
    ref = Ref.ref,
    computed = Computed.computed,
    reactive = reactive,
    new = Binder.apiNew,
    newBinder = Binder.apiNewBinder,
    use = use,
    createBinder = createBinder
}


return vlua
end)



---------------------------------------


__DISTILLER:define("plugins.generic.generic", function(require)
local vlua = require("vlua.vlua")
local Binder = require("vlua.binder")
local HookIds = Binder.HookIds

local Generic = {}

Generic.install = function()
end

return Generic

end)



---------------------------------------


__DISTILLER:define("plugins.xlua.ui", function(require)
local Binder = require("vlua.binder")

local ui = {}

ui.install = function()
    --- auto bind all uievent
    ---@param cb Function
    function Binder:bindUIEvent(event, cb)
        event:AddListener(cb)
        self:onUnmount(
            function()
                event:RemoveListener(cb)
            end
        )
    end

    --- one way bind to text
    ---@param text UnityEngine.ui.Text
    ---@param expOrFn fun():string | string
    function Binder:bindText(text, expOrFn)
        self:watch(expOrFn, function(source, value, oldValue)
            text.text = value
        end, true)
    end

    --- double way binding to inputfield
    function Binder:bindInputField(inputField, exp)
        -- one way to text
        self:watch(exp, function(source, value, oldValue)
            inputField.text = value
        end, true)
        -- one way to source
        self:bindUIEvent(inputField.onValueChanged, function(text)
            self.source[exp] = text
        end)
    end
end
return ui


end)



---------------------------------------


__DISTILLER:define("plugins.xlua.xlua", function(require)
local vlua = require('vlua.vlua')
local ui = require('plugins.xlua.ui')

local Generic = {}

Generic.install = function()
    vlua.use(ui)
end


return Generic
end)



---------------------------------------


__DISTILLER:define("vlua_xlua.lua_distilled", function(require)
local vlua = require('vlua.vlua')
vlua.use(require('plugins.generic.generic'))
vlua.use(require('plugins.xlua.xlua'))
return vlua
end)



---------------------------------------


return __DISTILLER:exec("vlua_xlua.lua_distilled")